<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KR on My Notes</title>
    <link>http://localhost:1313/NotesWebsite/kr/</link>
    <description>Recent content in KR on My Notes</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 18 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/NotesWebsite/kr/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>From Concept to knowledge</title>
      <link>http://localhost:1313/NotesWebsite/kr/from-concept-to-knowledge-in-el/</link>
      <pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/from-concept-to-knowledge-in-el/</guid>
      <description>&lt;p&gt;so far we described concepts and their relationships&lt;/p&gt;&#xA;&lt;p&gt;How do we express knowledge?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Trough constraints on the relevant interpretations (Tbox)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;A Tbox (terminological Box) is used to impose restrictions on the potential interpretation of concepts&lt;/p&gt;&#xA;&lt;p&gt;A ($\mathcal{EL}^\bot$) general concept inclusion &lt;code&gt;GCI&lt;/code&gt; is an expression $C \sqsubseteq D$ with C and D $\mathcal{EL}^\bot$ concepts&#xA;a TBox is a finite set of GCI&amp;rsquo;s&lt;/p&gt;&#xA;&lt;p&gt;an interpretation $\mathcal{I}$ satisfies the GCI  $C \sqsubseteq D$ iff $C^{\mathcal{I}} \subseteq D^\mathcal{I}$&lt;/p&gt;</description>
    </item>
    <item>
      <title>New KR language</title>
      <link>http://localhost:1313/NotesWebsite/kr/new-kr-language/</link>
      <pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/new-kr-language/</guid>
      <description>&lt;p&gt;$\mathcal{EL^\top}$&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Limited expression of predicate rules&lt;/li&gt;&#xA;&lt;li&gt;allows for constraints&lt;/li&gt;&#xA;&lt;li&gt;allows for anonymous objects&lt;/li&gt;&#xA;&lt;li&gt;has effective and efficient reasoning methods&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;$\mathcal{EL^\top}$ Belongs to a bigger family of KR languages knowns as DL&amp;rsquo;s (Description Logics)&#xA;Dl&amp;rsquo;s are a category of languages characterized by:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Clear syntax&lt;/li&gt;&#xA;&lt;li&gt;formal unambiguous semantics&#xA;The scope of DL&amp;rsquo;s is to provide reasoning, and the main goal is to have decidable reasoning services (sound, complete and terminating algorithms)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Most DL&amp;rsquo;s fall within the two variable fragment of first-order predicate logic (we can only use 2 variables)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Representing Individuals in ALC</title>
      <link>http://localhost:1313/NotesWebsite/kr/representing-individuals-in-alc/</link>
      <pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/representing-individuals-in-alc/</guid>
      <description>&lt;h2 id=&#34;aboxes&#34;&gt;ABoxes&lt;/h2&gt;&#xA;&lt;p&gt;Consider an infinite set $N_I$ of individual names, disjoint with $N_C \ \mbox{and} \ N_R$&lt;/p&gt;&#xA;&lt;p&gt;An &lt;strong&gt;Assertion&lt;/strong&gt; is an expression of the form&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$C(a)$ where $a \in N_I$ and C is an $\mathcal{ALC}$ concept&lt;/li&gt;&#xA;&lt;li&gt;$r(a,b)$ where $a,b \in N_I$ and $r \in N_R$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;An assertion box &lt;code&gt;ABox&lt;/code&gt; is a finite set of assertions&lt;/p&gt;&#xA;&lt;p&gt;this concepts is kinda similar to relational database $\to$ keep in mind that usually DB&amp;rsquo;s are complete (if a person isn&amp;rsquo;t in the student&amp;rsquo;s DB, he&amp;rsquo;s not a student ), while ABoxes aren&amp;rsquo;t and work with an &lt;strong&gt;Open World Assumption&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Type of Knowledge</title>
      <link>http://localhost:1313/NotesWebsite/kr/type-of-knowledge/</link>
      <pubDate>Mon, 18 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/type-of-knowledge/</guid>
      <description>&lt;p&gt;With all languages seen so far, knowledge is considered &lt;strong&gt;Static&lt;/strong&gt;&#xA;This is meaningful in many domains, but insufficient in the context of processes&lt;/p&gt;&#xA;&lt;p&gt;We need a way to deal with time and dynamic knowledge&lt;/p&gt;&#xA;&lt;h2 id=&#34;time&#34;&gt;Time&lt;/h2&gt;&#xA;&lt;p&gt;To deal with time we first have to decide if it&amp;rsquo;s&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;discrete&lt;/strong&gt; or &lt;strong&gt;continuous&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;linear&lt;/strong&gt; or &lt;strong&gt;branching&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;we will deal with time using $LTL_f$ (showcases the main ideas of temporal reasoning while still remaining pretty simple)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Extension of predicate rules</title>
      <link>http://localhost:1313/NotesWebsite/kr/extension-of-predicate-rules/</link>
      <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/extension-of-predicate-rules/</guid>
      <description>&lt;h1 id=&#34;rules-as-programming&#34;&gt;Rules as programming&lt;/h1&gt;&#xA;&lt;p&gt;we can read the rule $H \leftarrow B$ as &amp;ldquo;If B is true, then H is true&amp;rdquo;&#xA;Knowledge is then propagated in one direction, other than that, there are no limits beyond constraints.&#xA;What if we wanna express that a person has at most / at least 2 parents, or that someone is alive iff they are not dead (they are either alive or dead, they have to be one, they can&amp;rsquo;t be both)?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Inconsistent KBs</title>
      <link>http://localhost:1313/NotesWebsite/kr/inconsistent-kbs/</link>
      <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/inconsistent-kbs/</guid>
      <description>&lt;p&gt;In case of inconsistency, the canonical model might not be a model of our KB&#xA;To determine if a KB is inconsistent we have to keep in mind some things&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Constraints may lead to contradictory knowledge&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Platypus(perry) $\leftarrow$&lt;/li&gt;&#xA;&lt;li&gt;Duck(perry) $\leftarrow$&lt;/li&gt;&#xA;&lt;li&gt;$\leftarrow$ Duck(x), Platypus(x)&#xA;Inconsistent as an object can&amp;rsquo;t be both a platypus and a duck due to the &lt;strong&gt;Principle of Explosion&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;A KB is inconsistent iff it&amp;rsquo;s canonical interpretation is unsound&#xA;Reasoning requires us to look at the canonical interpretation only&lt;/p&gt;</description>
    </item>
    <item>
      <title>Representing Knowledge as Rules</title>
      <link>http://localhost:1313/NotesWebsite/kr/representing-knowledge-as-rules/</link>
      <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/representing-knowledge-as-rules/</guid>
      <description>&lt;p&gt;also see [[Boolean Algebra and Propositional Logic]]&lt;/p&gt;&#xA;&lt;h1 id=&#34;clauses&#34;&gt;Clauses&lt;/h1&gt;&#xA;&lt;p&gt;a clause is a ==disjunction== of literals &lt;code&gt;(variables or negated variables)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;some clauses&#xA;$$ x \vee y \vee \neg z $$&#xA;$$ \neg x \vee \neg y $$&lt;/p&gt;&#xA;&lt;h2 id=&#34;horn-clause&#34;&gt;Horn Clause&lt;/h2&gt;&#xA;&lt;p&gt;A Horn clause has at most 1 positive literal&lt;/p&gt;&#xA;&lt;p&gt;$x$&#xA;$x \vee \neg y \vee \neg z$&lt;/p&gt;&#xA;&lt;p&gt;We will represent Horn clauses in a different way&#xA;$(x_1 \wedge x_2 \wedge &amp;hellip; \wedge X_n) \rightarrow y$&#xA;Meaning if all X&amp;rsquo;s are true, then y must be true as well&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dealing with objects</title>
      <link>http://localhost:1313/NotesWebsite/kr/dealing-with-objects/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/dealing-with-objects/</guid>
      <description>&lt;p&gt;&lt;code&gt;Propositional logic&lt;/code&gt; is able to deal with only one item at a time&#xA;What if we want to relate different objects?&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ana is a professor&lt;/li&gt;&#xA;&lt;li&gt;Ana supervises bob&#xA;or&lt;/li&gt;&#xA;&lt;li&gt;A grandparents is the parent of a parent&lt;/li&gt;&#xA;&lt;li&gt;Uncles have siblings who are parents&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;What we have to do is extending the rules in order to handle predicate knowledge&#xA;uncle(x) $\leftarrow$ sibling(x, y), parent(x, y)&lt;/p&gt;&#xA;&lt;p&gt;From proposition to predicates&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Mammal&lt;/strong&gt; is a &lt;code&gt;propositional variable&lt;/code&gt; which is either True &lt;code&gt;or&lt;/code&gt; False&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;we can then represent more informations through predicates such as&lt;/p&gt;</description>
    </item>
    <item>
      <title>Boolean Algebra and Propositional Logic</title>
      <link>http://localhost:1313/NotesWebsite/kr/boolean-algebra-and-propositional-logic/</link>
      <pubDate>Sat, 05 Oct 2024 12:08:51 +0200</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/boolean-algebra-and-propositional-logic/</guid>
      <description>&lt;p&gt;Boolean algebra refers to the manipulation of truth values through logical operations.&#xA;We are gonna consider just 2 truth values&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;True &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;False &lt;code&gt;0&lt;/code&gt;&#xA;and 3 Boolean Operators to manipulate the values&lt;/li&gt;&#xA;&lt;li&gt;Conjunction (∧) &lt;code&gt;And&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Disjunction (∨) &lt;code&gt;Or&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Negation (¬) &lt;code&gt;Not&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;In Boolean Algebra we compute complex expressions of Logic Operators containing variables&lt;/p&gt;&#xA;&lt;h1 id=&#34;propositional-logic&#34;&gt;Propositional Logic&lt;/h1&gt;&#xA;&lt;p&gt;Propositional logic is used to combine propositions and studying their truth values&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Atomic Propositions state one fact or one property &lt;code&gt;Mammals are vertebreae&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;formulas&#34;&gt;Formulas&lt;/h2&gt;&#xA;&lt;p&gt;==Formulas== are used to combine propositions&#xA;[[Logic]] is still a language so we must specify&lt;/p&gt;</description>
    </item>
    <item>
      <title>History of KR</title>
      <link>http://localhost:1313/NotesWebsite/kr/history-of-kr/</link>
      <pubDate>Sat, 05 Oct 2024 12:08:51 +0200</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/history-of-kr/</guid>
      <description>&lt;p&gt;History is deeply connected with recording techniques such as writing or oral traditions (humans always felt the need to transmit knowledge, `this was done trough myths, stories, etc.)&lt;/p&gt;&#xA;&lt;p&gt;Oral and written traditions preserve and propagate knowledge&#xA;traditions hardly resist the test of time, their meaning easily change, and they&amp;rsquo;re also very hard to update, the language could also result ambiguous&#xA;Our goal is to represent knowledge with guarantees without the need of Trained Interpreters (like in religious text)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Logic</title>
      <link>http://localhost:1313/NotesWebsite/kr/logic/</link>
      <pubDate>Sat, 05 Oct 2024 12:08:51 +0200</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/logic/</guid>
      <description>&lt;p&gt;Type of language without the nuances (you write exactly whatever you mean , every sentence has 1 meaning)&#xA;we will use logic to manipulate knowledge, associating expressions with their meaning&lt;/p&gt;&#xA;&lt;p&gt;Reasoning needs ==guarantees&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;After reading the party examples from the slides (example of a constraint satisfaction problem)&lt;/code&gt;&#xA;We couldn&amp;rsquo;t respond to the question &amp;ldquo;Who&amp;rsquo;s invited as there isn&amp;rsquo;t a single viable answer&amp;rdquo;, however we can say for sure that the party is possible&lt;/p&gt;</description>
    </item>
    <item>
      <title>Logic and Symbolic AI</title>
      <link>http://localhost:1313/NotesWebsite/kr/logic-and-symbolic-ai/</link>
      <pubDate>Sat, 05 Oct 2024 12:08:51 +0200</pubDate>
      <guid>http://localhost:1313/NotesWebsite/kr/logic-and-symbolic-ai/</guid>
      <description>&lt;h1 id=&#34;intelligence&#34;&gt;Intelligence&lt;/h1&gt;&#xA;&lt;p&gt;AI deals with machines showing intelligent traits, isn&amp;rsquo;t equivalent to humane cognitive attributes&#xA;Humans work on 2 different thought processes; ==system 1 (reflexes, fast and intuitive) and system 2 (Used in thought, slow and more logical, takes effort and time)&lt;/p&gt;&#xA;&lt;p&gt;System 1 is useful for simple task but can be easily fooled (Pareidolia) it&amp;rsquo;s also hard wired and hard to modify it (In AI creation and modification of it can be very expensive as it needs time and repetition to build a strong muscle memory)&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
