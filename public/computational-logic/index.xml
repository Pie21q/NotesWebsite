<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computational Logic on My Notes</title>
    <link>http://localhost:1313/NotesWebsite/computational-logic/</link>
    <description>Recent content in Computational Logic on My Notes</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 11 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/NotesWebsite/computational-logic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exercise: Ball</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/balls/</link>
      <pubDate>Wed, 11 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/balls/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(define-fun PRE ((b Int) (w Int)) Bool (and (= b 9) (= w 10)))&#xA;(define-fun POST   ((b Int) (w Int)) Bool (and (= b 1) (= w 0)))&#xA;&#xA;(define-fun TRANS &#xA;            ((b Int) (w Int) (bp Int) (wp Int)) Bool&#xA;             (and (&amp;lt;= 0 bp) (&amp;lt;= 0 wp)&#xA;              (or &#xA;                 (and (= bp ( + b 1))(= wp (- w  2)))&#xA;                 (= bp (- b 1))&#xA;                 (= bp (- b 1))&#xA;              )&#xA;             )&#xA;            )  &#xA;&#xA;&#xA;&#xA;(declare-const x0 Int )&#xA;(declare-const y0 Int)&#xA;&#xA;&#xA;(declare-const x1 Int )&#xA;(declare-const y1 Int)&#xA;&#xA;(declare-const x2 Int )&#xA;(declare-const y2 Int)&#xA;&#xA;(declare-const x3 Int )&#xA;(declare-const y3 Int)&#xA;&#xA;(declare-const x4 Int )&#xA;(declare-const y4 Int)&#xA;&#xA;&#xA;(declare-const x5 Int )&#xA;(declare-const y5 Int)&#xA;&#xA;&#xA;(declare-const x6 Int )&#xA;(declare-const y6 Int)&#xA;&#xA;&#xA;(declare-const x7 Int )&#xA;(declare-const y7 Int)&#xA;&#xA;&#xA;(declare-const x8 Int )&#xA;(declare-const y8 Int)&#xA;&#xA;&#xA;(declare-const x9 Int )&#xA;(declare-const y9 Int)&#xA;&#xA;&#xA;(declare-const x10 Int )&#xA;(declare-const y10 Int)&#xA;&#xA;&#xA;(declare-const x11 Int )&#xA;(declare-const y11 Int)&#xA;&#xA;&#xA;(declare-const x12 Int )&#xA;(declare-const y12 Int)&#xA;&#xA;(declare-const x13 Int )&#xA;(declare-const y13 Int)&#xA;&#xA;(declare-const x14 Int )&#xA;(declare-const y14 Int)&#xA;&#xA;(declare-const x15 Int )&#xA;(declare-const y15 Int)&#xA;&#xA;(declare-const x16 Int )&#xA;(declare-const y16 Int)&#xA;&#xA;(declare-const x17 Int )&#xA;(declare-const y17 Int)&#xA;&#xA;(declare-const x18 Int )&#xA;(declare-const y18 Int)&#xA;&#xA;(declare-const x19 Int )&#xA;(declare-const y19 Int)&#xA;&#xA;(declare-const x20 Int )&#xA;(declare-const y20 Int)&#xA;&#xA;(declare-const x21 Int )&#xA;(declare-const y21 Int)&#xA;&#xA;(declare-const x22 Int )&#xA;(declare-const y22 Int)&#xA;&#xA;(declare-const x23 Int )&#xA;(declare-const y23 Int)&#xA;&#xA;(declare-const x24 Int )&#xA;(declare-const y24 Int)&#xA;&#xA;(declare-const x25 Int )&#xA;(declare-const y25 Int)&#xA;&#xA;&#xA;&#xA;(assert (PRE x0 y0 ) )&#xA;&#xA;&#xA;(assert (TRANS x0 y0 x1 y1 ) )&#xA;(assert (TRANS x1 y1 x2 y2 ) )&#xA;(assert (TRANS x2 y2 x3 y3 ) )&#xA;(assert (TRANS x3 y3 x4 y4 ) )&#xA;(assert (TRANS x4 y4 x5 y5 ) )&#xA;(assert (TRANS x5 y5 x6 y6 ) )&#xA;(assert (TRANS x6 y6 x7 y7 ) )&#xA;(assert (TRANS x7 y7 x8 y8 ) )&#xA;(assert (TRANS x8 y8 x9 y9 ) )&#xA;(assert (TRANS x9 y9 x10 y10 ) )&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;(assert (POST x10 y10 ) )&#xA;&#xA;&#xA;&#xA;(check-sat)&#xA;&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 0&amp;#34;)&#xA;(eval x0)&#xA;(eval y0)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 1&amp;#34;)&#xA;(eval x1)&#xA;(eval y1)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 2&amp;#34;)&#xA;(eval x2)&#xA;(eval y2)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 3&amp;#34;)&#xA;(eval x3)&#xA;(eval y3)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 4&amp;#34;)&#xA;(eval x4)&#xA;(eval y4)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 5&amp;#34;)&#xA;(eval x5)&#xA;(eval y5)&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 6&amp;#34;)&#xA;&#xA;&#xA;&#xA;(eval x6)&#xA;(eval y6)&#xA;&#xA;(echo &amp;#34; &amp;#34;)&#xA;(echo &amp;#34;step 10&amp;#34;)&#xA;&#xA;&#xA;&#xA;(eval x10)&#xA;(eval y10)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>CDCL</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/cdcl/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/cdcl/</guid>
      <description>&lt;p&gt;Review online lesson 25 / 10 / 2024 for explanation and examples&lt;/p&gt;&#xA;&lt;h2 id=&#34;cdcl&#34;&gt;CDCL&lt;/h2&gt;&#xA;&lt;p&gt;each step is structured like&#xA;$$(V \ | \ F \ | \ \alpha)$$&#xA;where&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$V$ is a partial assignment (for example $p_1, p_2, p_3$ or $p_1, \bar{p_2}$), in the end we expect to get either a failure (UNSAT), or a total assignment, where all the literals are present&lt;/li&gt;&#xA;&lt;li&gt;$F$ is a set of clauses containing both original clauses and additional clauses which we call &amp;rsquo;learnt&#39;&lt;/li&gt;&#xA;&lt;li&gt;$\alpha$ can either be the &amp;lsquo;search mode&amp;rsquo;, or a clause known as the conflict clause&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The initial status is&#xA;$$(\emptyset \ | \ F_0 \ | \ *)$$&#xA;where&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exercise: In pizzeria</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/pizza/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/pizza/</guid>
      <description>&lt;h1 id=&#34;in-pizzeria&#34;&gt;In pizzeria&lt;/h1&gt;&#xA;&lt;p&gt;Exercise on &lt;a href =&#39;https://drive.google.com/drive/u/1/folders/1kL-sjIOiib0rL_7T1OGVIvJnYWH2_Jnh&#39;&gt;Drive&lt;/a&gt; &lt;br&gt;&#xA;The customers have been named from a to f, starting from the top left&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(declare-const a Real)&#xA;(declare-const b Real)&#xA;(declare-const c Real)&#xA;(declare-const d Real)&#xA;(declare-const e Real)&#xA;(declare-const f Real)&#xA;(assert(= (+ a b) (+ e f)))&#xA;(assert(&amp;lt; b a))&#xA;(assert(or (= c 9.5)(= c 7.5)(= c 8.5)(= c 7)))&#xA;(assert(or (= d 9)(= d 9.5)))&#xA;(assert(or (= e 9)(= e 9.5)))&#xA;(assert(or (= f 9)(= f 7)))&#xA;(assert(or (= a 9.5)(= a 7.5)(= a 8.5)(= a 7)(= a 8)(= a 9)))&#xA;(assert(or (= b 9.5)(= b 7.5)(= b 8.5)(= b 7)(= b 8)(= b 9)))&#xA;(assert(distinct a b c d e f))&#xA;(check-sat)&#xA;(get-value(a b c d e f))&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Exercise: Tetravex</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/tetravex/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/tetravex/</guid>
      <description>&lt;h1 id=&#34;tetravex&#34;&gt;Tetravex&lt;/h1&gt;&#xA;&lt;p&gt;Exercise on &lt;a href =&#39;https://drive.google.com/drive/u/1/folders/1kL-sjIOiib0rL_7T1OGVIvJnYWH2_Jnh&#39;&gt;Drive&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Positions are named 0-8 starting from top left and ending bottom right&lt;/li&gt;&#xA;&lt;li&gt;Tiles are named from a to i&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(declare-datatypes () (( Tiles a b c d e f g h i)))&#xA;(declare-fun Left(Tiles) Int)&#xA;(declare-fun Right(Tiles) Int)&#xA;(declare-fun Top(Tiles) Int)&#xA;(declare-fun Bot(Tiles) Int)&#xA;(declare-fun Position(Tiles) Int )&#xA;(assert(= (Left a) 3))&#xA;(assert(= (Right a) 8))&#xA;(assert(= (Top a) 3))&#xA;(assert(= (Bot a) 1))&#xA;&#xA;(assert(= (Left b) 8))&#xA;(assert(= (Right b) 1))&#xA;(assert(= (Top b) 1))&#xA;(assert(= (Bot b) 6))&#xA;&#xA;(assert(= (Left c) 3))&#xA;(assert(= (Right c) 8))&#xA;(assert(= (Top c) 0))&#xA;(assert(= (Bot c) 3))&#xA;&#xA;(assert(= (Left d) 7))&#xA;(assert(= (Right d) 2))&#xA;(assert(= (Top d) 6))&#xA;(assert(= (Bot d) 6))&#xA;&#xA;(assert(= (Left e) 2))&#xA;(assert(= (Right e) 5))&#xA;(assert(= (Top e) 4))&#xA;(assert(= (Bot e) 0))&#xA;&#xA;(assert(= (Left f) 4))&#xA;(assert(= (Right f) 7))&#xA;(assert(= (Top f) 3))&#xA;(assert(= (Bot f) 5))&#xA;&#xA;(assert(= (Left g) 5))&#xA;(assert(= (Right g) 3))&#xA;(assert(= (Top g) 9))&#xA;(assert(= (Bot g) 0))&#xA;&#xA;(assert(= (Left h) 1))&#xA;(assert(= (Right h) 1))&#xA;(assert(= (Top h) 4))&#xA;(assert(= (Bot h) 4))&#xA;&#xA;&#xA;(assert(= (Left i) 8))&#xA;(assert(= (Right i) 8))&#xA;(assert(= (Top i) 4))&#xA;(assert(= (Bot i) 4))&#xA;&#xA;(assert(exists ((x Tiles)(y Tiles)(z Tiles))  (and (=(Position x) 0) (=(Position y)1) (=(Right x)(Left y)) (=(Position z ) 3) (=(Bot x)(Top z))  )))&#xA;(assert(exists ((x Tiles)(y Tiles)(z Tiles))  (and (=(Position x) 1) (=(Position y)4) (=(Bot x)(Top y)) (=(Position z ) 2 ) (=(Right x)(Left z))  )))&#xA;(assert(exists ((x Tiles)(y Tiles))  (and (=(Position x) 2) (=(Position y)5) (=(Bot x)(Top y)) )))&#xA;(assert(exists ((x Tiles)(y Tiles)(z Tiles))  (and (=(Position x) 3) (=(Position y)4) (=(Right x)(Left y)) (=(Position z ) 6 ) (=(Bot x)(Top z))  )))&#xA;(assert(exists ((x Tiles)(y Tiles)(z Tiles))  (and (=(Position x) 4) (=(Position y)7) (=(Bot x)(Top y)) (=(Position z ) 5 ) (=(Right x)(Left z))  )))&#xA;(assert(exists ((x Tiles)(y Tiles))  (and (=(Position x) 5) (=(Position y)8) (=(Bot x)(Top y)) )))&#xA;(assert(exists ((x Tiles)(y Tiles))  (and (=(Position x) 6) (=(Position y)7) (=(Right x)(Left y)) )))&#xA;(assert(exists ((x Tiles)(y Tiles))  (and (=(Position x) 7) (=(Position y)8) (=(Right x)(Left y)) )))&#xA;&#xA;(check-sat)&#xA;(get-value((Position a)(Position b)(Position c)(Position d)(Position e)(Position f)(Position g)(Position h)(Position i)))&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Exercise: Square Frame</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/exercise-square-frame/</link>
      <pubDate>Wed, 27 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/exercise-square-frame/</guid>
      <description>&lt;p&gt;You are given the following 10 tiles:&#xA;[1 | 3] , [6 | 1] , [3 | 2] , [9 | 6] ,&#xA;[1 | 2] , [4 | 9] , [2 | 6] , [2 | 4] , [6 | 1] , [2 | 2].&lt;/p&gt;&#xA;&lt;p&gt;Each tile has two cells, with numbers printed inside them. Arrange the tiles in a square frame&#xA;(’cornice quadrata’) in such a way that two adjacent cells have the sa-&#xA;me number (or show that no such arrangement exists). [Hint: use the&#xA;declare-datatypes utility to declare the 10-members set comprising your&#xA;tiles. Then introduce two Int-valued functions representing the content of&#xA;the left and the right cells. Use a further Int-valued function to formalize&#xA;the position (from 1 to 10) of each tile in the solution frame.]&lt;/p&gt;</description>
    </item>
    <item>
      <title>First Order Logic</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/first-order-logic/</link>
      <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/first-order-logic/</guid>
      <description>&lt;h2 id=&#34;socrates-is-a-man&#34;&gt;All man are mortal&#xA;Socrates is a man&lt;/h2&gt;&#xA;&lt;p&gt;Socrates is mortal&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\forall x (Man(x) \rightarrow Mortal(x))$&lt;/li&gt;&#xA;&lt;li&gt;$Man(Socrates)$&lt;/li&gt;&#xA;&lt;li&gt;$Mortal(Socrates)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;First Order logic includes&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Names for objects &lt;code&gt;individual constants&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Names for operations &lt;code&gt;function symbols&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Names for properties and relations &lt;code&gt;operations&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;$\mathcal{l} = &amp;lt; \mathcal{F, P}, \alpha &amp;gt;$&#xA;where&#xA;$\mathcal{F}$ is the set of operation symbols&#xA;$\mathcal{P}$ is the set of predicates&#xA;$\alpha$ is a function which tells us how many arguments an operation can take&lt;/p&gt;</description>
    </item>
    <item>
      <title>Z3, basic notions and syntax</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/z3-lab-instructions/</link>
      <pubDate>Wed, 16 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/z3-lab-instructions/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;(declare-const p Bool)&lt;/code&gt; is declaring a variable named P&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;;&lt;/code&gt; comments are done through semicolons&lt;/li&gt;&#xA;&lt;li&gt;formulas are declared using &lt;code&gt;not, and, or, =&amp;gt;, =&lt;/code&gt;, the symbols must be prefixed, for example to write $p \vee q$  you would write &lt;code&gt;(or p q)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(assert(formula))&lt;/code&gt; adds the formula to the check-sat&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;(check-sat)&lt;/code&gt; verifies if the formula can be True&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;To check if a formula $\mathcal{A}$ is a Tautology we first negate the formula and then we verify if $\neg{A}$ is unsatisfiable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Computational Logic, From SAT to SMT</title>
      <link>http://localhost:1313/NotesWebsite/computational-logic/computational-logic-from-sat-to-smt/</link>
      <pubDate>Fri, 11 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/NotesWebsite/computational-logic/computational-logic-from-sat-to-smt/</guid>
      <description>&lt;h2 id=&#34;propositional-logic&#34;&gt;Propositional Logic&lt;/h2&gt;&#xA;&lt;p&gt;Refer to the KR notes on the same topic&lt;/p&gt;&#xA;&lt;p&gt;Remember that&#xA;$$ \rightarrow means \space if, \space while\space \leftrightarrow \space means \space if \space and\space only\space if $$&#xA;Some expressions make perfect sense, like&#xA;$$(p\vee q) \rightarrow r$$&#xA;&lt;code&gt;If it rains (p) or it snows (q), then i will take an umbrella (r)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;while others are meaningless&#xA;$$pq)) \rightarrow r$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;formula&#34;&gt;Formula&lt;/h2&gt;&#xA;&lt;p&gt;A formula is a string of characters which follows the following rules&#xA;$Every \space p \in L \space is \ a \ formula \ (rule \ n1) \ if \ all \ A,B&amp;rsquo;s \ are \ formulas, then \ (A \vee B) \ and \ (A \wedge B) \ are \ also \ formulas \ (rule \ n2)$&#xA;we can also create a tree from the main formula, where the nodes are built using rule 2 and the last elements using rule 1&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
